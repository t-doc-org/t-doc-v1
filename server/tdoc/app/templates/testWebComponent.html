<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta http-equiv="content-language" content="en">

  <!-- Pour éviter l'erreur avec favicon.ico qui n'existe pas -->
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <script type="text/javascript">
// MathJax normally operates on whole documents. It doesn't natively know how
// to handle shadow DOMs. The code below hooks into various components to allow
// it to render in shadow DOMs. It is a cleaned-up version of code taken from:
//
// https://github.com/mathjax/MathJax/issues/2162#issuecomment-506962519
// https://github.com/mathjax/MathJax/issues/2195#issuecomment-533840961
// https://github.com/mathjax/MathJax/issues/2590#issuecomment-751398270
window.MathJax = {
  tex: {
    tags: "ams",
    inlineMath: [['$', '$'], ['\\(', '\\)']],
  },
  options: {
    skipHtmlTags: {'[+]': ['tdoc-latex']}
  },
  startup: {
    ready: () => {
      const mathjax = MathJax._.mathjax.mathjax;
      const HTMLAdaptor = MathJax._.adaptors.HTMLAdaptor.HTMLAdaptor;
      const HTMLHandler = MathJax._.handlers.html.HTMLHandler.HTMLHandler;
      const AbstractHandler = MathJax._.core.Handler.AbstractHandler.prototype;
      const startup = MathJax.startup;

      // Extend HTMLAdaptor to handle the shadow DOM as the document.
      class ShadowAdaptor extends HTMLAdaptor {
        create(kind, ns) {
          const doc = (this.document.createElement ? this.document
                       : this.window.document);
          return (ns ? doc.createElementNS(ns, kind) : doc.createElement(kind));
        }

        text(text) {
          const doc = (this.document.createTextNode ? this.document
                       : this.window.document);
          return doc.createTextNode(text);
        }

        head(doc) {
          return doc.head || (doc.firstChild || {}).firstChild || doc;
        }

        body(doc) {
          return doc.body || (doc.firstChild || {}).lastChild || doc;
        }

        root(doc) {
          return doc.documentElement || doc.firstChild || doc;
        }
      }

      // Extend HTMLHandler to handle the shadow DOM as the document.
      class ShadowHandler extends HTMLHandler {
        create(doc, options) {
          const adaptor = this.adaptor;
          if (typeof(doc) === 'string') {
            doc = adaptor.parse(doc, 'text/html');
          } else if ((doc instanceof adaptor.window.HTMLElement ||
                      doc instanceof adaptor.window.DocumentFragment) &&
                     !(doc instanceof window.ShadowRoot)) {
            const child = doc;
            doc = adaptor.parse('', 'text/html');
            adaptor.append(adaptor.body(doc), child);
          }
          // We can't use super.create() here, because it doesn't handle the
          // shadow DOM correctly. So we call HTMLHandler's parent class
          // directly instead.
          return AbstractHandler.create.call(this, doc, options);
        }
      }

      // Register the new handler and adaptor.
      startup.registerConstructor('HTMLHandler', ShadowHandler);
      startup.registerConstructor('browserAdaptor',
                                  () => new ShadowAdaptor(window));

      // Create a new MathDocument from the shadow root with the configured
      // input and output jax, then render the document.
      MathJax.typesetShadow = function (root) {
        const InputJax = startup.getInputJax();
        const OutputJax = startup.getOutputJax();
        const html = mathjax.document(root, {InputJax, OutputJax});
        html.render();
        return html;
      }

      MathJax.typesetShadowPromise = function (root) {
        const InputJax = startup.getInputJax();
        const OutputJax = startup.getOutputJax();
        const html = mathjax.document(root, {InputJax, OutputJax});
        return mathjax.handleRetriesFor(() => html.render());
      }

      // Continue with the usual startup.
      MathJax.startup.defaultReady();
    }
  }
};
  </script>
  <script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js' type='text/javascript'></script>

  <script type="text/javascript">
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(
                  cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

class LatexComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({mode: 'open'});
    this.observer = new MutationObserver(async (mutation) => {
      this.render();
    });
  }

  async connectedCallback() {
    await this.render();
    this.observer.observe(this, {childList: true, characterData: true,
                                 subtree: true});
  }

  disconnectedCallback() {
    this.observer.disconnect();
  }

  async render() {
    console.log("render");
    const text = this.textContent;
    if (!text) return;

    console.log("performing rendering");
    const response = await fetch('/render-latex', {
      method: 'POST',
      headers: {'X-CSRFToken': getCookie('csrftoken')},
      mode: 'same-origin',
      cache: 'no-cache',
      body: text,
    })
    const html = await response.text()
    console.log("response received");
    MathJax.typesetClear([this.shadowRoot.firstChild]);
    this.shadowRoot.innerHTML = '<mjx-doc><mjx-head></mjx-head><mjx-body>' +
                                html + '</mjx-body></mjx-doc>';
    await MathJax.typesetShadowPromise(this.shadowRoot);
  }
}

customElements.define('tdoc-latex', LatexComponent);
  </script>


  <title>Test du LaTeX WebComponent</title>
</head>

<body>
  <h1>Envoyer du latex au serveur</h1>

  <p id="p1"> Ceci est un document qui contient un paragraphe et du latex.</p>

  <tdoc-latex>
\documentclass[a4paper,11pt]{article}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}

\usepackage{amssymb,amsmath,amsfonts, amsfonts}
\usepackage{enumitem}
\usepackage{array}
\usepackage{multicol}

\begin{document}
\section{Équations du deuxième degré}
\subsection{théorie}
<!-- Toute équation quadratique donnée sous la forme $ax^2+bx+c=0 a \ne 0$ (a  \ne 0 en version texte est ok).
peut être résolue à l'aide de la formule suivante
$$x_{1,2}=\dfrac{-b \pm \sqrt{b^2-4ac}}{2a}$$
${x_1}$ et ${x_2}$ sont appelées les \textbf{racines} du trinôme.\\ -->
L'expression sous la racine $$\Delta= \mathbf{b^2-4ac}$$ est appelée le \textbf{discriminant} et détermine le nombre de solutions d'une équation quadratique:\\
$\begin{array}{|l | l |}
\hline
\Delta>0 & \text{L'équation a \textbf{deux solutions} réelles} \\
& \text{Le polynôme factorisé est de la forme:}  a(x - x_{1})(x - x_{2}) \\
\hline
\Delta=0 & \text{L'équation a \textbf{une solution} réelle (solution double)}\\
& \text{Le polynôme factorisé est de la forme:}  a(x - x_{1})^2\\
\hline
\Delta<0 & \text{L'équation \textbf{n'a pas de solution} réelle}\\
& \text{Le polynôme ne peut pas être factorisé.}\\
\hline
\end{array}$\par
<!-- Listes non numérotées:\par
\begin{itemize}
\item $2x^2+6x-8=0$ possède deux solutions.
\item L'équation $4x^2+2=4x$ n'a pas de solution.
\item L'équation $\frac{3}{2}x^2+6x+6=0$ possède une solution.
\end{itemize}
Listes numérotées la numérotation ne peut pas être changée:\par
\begin{enumerate}
\item $2x^2+6x-8=0$ possède deux solutions.
\begin{enumerate}
\item item 1
\item item 2
\end{enumerate}
\item L'équation $4x^2+2=4x$ n'a pas de solution.
\item L'équation $\dfrac{3}{2}x^2+6x+6=0$ possède une solution.
\end{enumerate}
Multicolonnes:\par
\begin{multicols}{3}
Voici ma première colonne qui ne raconte pas grand chose, mais ce n'est pas grave, car ce n'est pas le but.\par
Voici ma deuxième colonne qui ne raconte pas grand chose, mais ce n'est pas grave, car ce n'est pas le but.\par
Voici ma troisième colonne qui ne raconte pas grand chose, mais ce n'est pas grave, car ce n'est pas le but.\par
\end{multicols}

\subsection{Exercices}

\begin{enumerate}
\item Résoudre les équations suivantes et écrire le polynôme sous forme factorisée.
\begin{multicols}{2}
\begin{enumerate}
\item $2x^2=50$
\item $4x^2-9x=0$
\item$x^2+6x=-9$
\item $\dfrac{5}{3}x^2+3x+1=0$
\end{enumerate}
\end{multicols}


\item En diminuant deux côtés parallèles d'un carré de $2\,cm$ et en prolongeant les deux autres côtés de $5\,cm$, on obtient un rectangle dont l'aire vaut $11\,cm^2$ de plus que celle du carré original.\\ Quelle est la longueur du côté du carré?

\item Quel nombre positif est de 48.75 inférieur à son carré?

\item Si on augmente de $30\,cm$ le rayon d'un cercle, son aire est triplée. Que vaut le rayon initial?

\end{enumerate}

Solution:\par
$S=\{5;-5\}$ et $P(x) = 2(x-5)(x+5)$\par
Résolution d'équations: \par
$\begin{array}{rclrl}
x^2 + 4 & \geq & 5x &|& -5x \\
x^2 -5x + 4 & \geq & 0 &|& \text{ (factorisation)} \\
(x-4)(x-1) & \geq & 0 &|& \\
\end{array}$

$\begin{array}{rclrl}
x^2 + 4 & \geq & 5x &|& -5x \\
x^2 -5x + 4 & \geq & 0 &|& \text{ (factorisation)} \\
(x-4)(x-1) & \geq & 0 &|& \\
\end{array}$\par
Maintenant il faut étudier le signe de $(x-4)(x-1)$\par
Les zéros de l'équations $(x-4)(x-1)=0$ sont 4 et 1.\par
$\begin{array}{|c|c c c c c c c|}
\hline
\text{facteurs} & -\infty &  & 1 & & 4& & +\infty\\
\hline
x-4 & & - & - & - & 0& + & \\
\hline
x-1 & & - & 0 & + & +& + & \\
\hline
(x-4)(x-1) & & + & 0 & - & 0& + & \\
\hline
\end{array}$\par -->

\end{document}
  </tdoc-latex>

</body>

</html>
